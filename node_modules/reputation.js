/* reputation.js 
 *
 * Provides functions for calculating and updating a user's reputation score 
 *
 * In calculating the reputation of user, we focus on two primary aspects: 
 * 1) Participation/contribution (e.g. voting on issues, voting on comments, adding issues)
 * 2) Quality of contributions (e.g. offensive material, length) 
 * 
 * There is a minimum reputation level enforced for users. Users will never fall 
 * below this reputation level in order to decrease the incentive for a user 
 * to abandon their account and start over if they accumulate a large negative reputation. 
 * 
 * There is also a maximum reputation level enforced for users.  Users reputations are 
 * capped in order to prevent a few users from dominating the discussion. 
 *
 * The reputation system is based on 'actions'. For example, the action of 
 * adding an issue an issue will improve your reputation by a certain amount. 
 * Actions can affect multiple users. For example, a user voting on a issue 
 * will affect their own reputation and the reputation of the issue author.  
 * 
 *  
 * Some other possible factors and improvements that can be made to the reputation system include: 
 * Other possible factors and improvements 
 * - Factor in the length of time a user has been a part of the community 
 * - Weight people with good reputations more so that when they upvote
 *   an issue, more points will be given to the issue owner. 
 * - Factor in how recently active a user is. Active users may have more weight 
 *   than inactive users. 
 */
 
var dbAccess = require('dbAccess'), 
	step = require('step'), 
	wordFilter = require('wordFilter'); 

var Direction = { 'Up' : 0, 'Down' : 1 }; 
	
/* Point Parameters */
var minScore = 0; 
var maxScore = 100000; 

var signUpPoints = 10; 

var addIssuePoints = 5; 
var issueVotePoints = 1; 

var addCommentPoints = 1; 
var commentedOnPoints = 1;
var commentLengthDeduction = 1; 
var commentMaxOffensiveWordDeduction = 3; 

/* getReputation
 * Gets the reputation score of a specified user 
 *
 * @param userId The id of the user 
 * @param callback The callback function (error, score) where score is the retrieved reputation of the user
 */
exports.getReputation = function(userId, callback) {
	dbAccess.find('users', { properties:['reputation_score'], conditions: ['id="' + userId + '"'] }, 
		function(error, results) {
			if (error || results.length != 1) {  
				if (callback instanceof Function) callback(error, -1);
			}
			else { 
				if (callback instanceof Function) callback(null, results[0].reputation_score);
			} 
		}
	); 
}

/* addToReputation
 * Add a specified value to the reputation score 
 * 
 * @param userId The id of the user
 * @param value The value (positive or negative) to add to the reputation score 
 * @param callback The callback (error, updatedScore) where score is update reputation of the user  
 */ 
function addToReputation (userId, value, callback) {
	exports.getReputation(userId, function(error, score) {
		if (error) { 
			if (callback instanceof Function) callback(error, score); 
		}
		else { 
			var newScore = score + value;
			setReputation(userId, newScore, function(err, updatedScore) {
				if (error) { 
					if (callback instanceof Function) callback(error, updatedScore);
				}				
				else { 
					if (callback instanceof Function) callback(null, updatedScore);
				}					
			});
		}
	});
}

/* setReputation 
 * Sets the reputation of a user to a specified 
 * 
 * @param userId The id of the user
 * @param value The value to set the reputation score to  
 * @param callback The callback (error, repValue) where repValue is the reputation of the user
 */ 
function setReputation(userId, value, callback) {
	var repValue; 
	if (value < minScore) repValue = minScore;
	else if (value > maxScore) repValue = maxScore;
	else repValue = value; 
	dbAccess.update('users', { values:[ 'reputation_score="' + repValue + '"' ], 
		conditions:['id="' + userId + '"'] }, function(error) { 
			if (error) { 
				if (callback instanceof Function) callback(error, repValue); 
			}
			else { 
				if (callback instanceof Function) callback(null, repValue); 
			}
	}); 
}

/* resetReputation
 * Resets the repuation score of a specified user to the lowest possible value.  
 * 
 * @param userId The id of the user 
 */
function resetReputation(userId) {
	setReputation(userId, minScore); 
}

/* countIssues 
 * Counts the number of issues opened by a specified user 
 * 
 * @param userId The id of the user 
 * @param callback The callback function which returns number of issues by a user
 */
function countIssues(userId, callback) { 
	var sql = 'SELECT COUNT(*) AS "num_issues" FROM issues WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (error) throw error;
		if (callback instanceof Function) { 
			callback(results[0].num_issues); 
		} 
	});
}

/* countComments 
 * Counts of the number of comments made by a user
 * 
 * @param userId The id of the user 
 * @param callback The callback function which returns number of comments by a user 
 */
function countComments(userId, callback) {
	var sql = 'SELECT COUNT(*) AS "num_comments" FROM comments WHERE user_id=' + userId;
	dbAccess.runQuery(sql, function(error, results) {
		if (error) throw error;
		if (callback instanceof Function) { 
			callback(results[0].num_comments); 
		} 
	});
}

/* getOffensiveMaterialDeduction 
 * Calculates the reputation point deduction for a given text string
 * based on the amount of offensive words within the text.  
 *
 * @param text The string to be analyzed 
 */ 
function getOffensiveMaterialDeduction(text) {
	var maximumDeduction = commentMaxOffensiveWordDeduction; 
	var offensiveWordCount = wordFilter.countOffensiveWords(text); 
	return (offensiveWordCount > maximumDeduction) ? -maximumDeduction : -offensiveWordCount; 
}

/* getCommentLengthDeduction
 * Calculates the reputation point deduction for a given text string
 * based on the amount of length of the text. 
 *  
 * Generally, relatively short comments (i.e. 1 - 3 words) are poor 
 * contributions to discussions. As a result, it is recommended that such comments 
 * result in a reputation point reduction to the commenter.   
 * 
 * @param text The string to be analyzed 
 */ 
function getCommentLengthDeduction(comment) {
	var minimumCommentLength = 3; 
	var commentLength = comment.split(/\s+/).length;
	return (commentLength <= minimumCommentLength) ? -commentLengthDeduction : 0; 
}

/* updateOnIssueVote 
 * A helper function which update reputations for the issue author and voter when an issue is voted upon.
 *
 * @param issueId The id of the issue that was voted on
 * @param userId The id of the user who voted 
 * @param direction The vote direction (up or down) 
 * @param callback The callback (err); 
 */ 
function updateOnIssueVote(issueId, userId, direction, callback) {
	getIssueAuthor(issueId, function(error, results) { 
		if (error) { 
			if (callback instanceof Function) return callback(error); 
		}
		else if (results.length != 1) { 
			if (callback instanceof Function) return callback('Comment author not found'); 
		}
		else { 
			var points = (direction == Direction.Up) ? issueVotePoints : -issueVotePoints; 
			addToReputation(results[0].user_id, points, function(authErr, authScore) { 
				if (error) { 
					if (callback instanceof Function) callback(authErr);
				}
				else { 
					addToReputation(userId, points, function(voterErr, voterScore) { 
						if (callback instanceof Function) callback(voterErr);
					}); 
				}
			}); 
		}
	});
}

/* getIssueAuthor
 * Gets the author of the issue 
 * 
 * @param issueId The id of the issue 
 * @param callback Returns callback (error, results)
 */
function getIssueAuthor(issueId, callback) { 
	dbAccess.find('issues', { properties:['user_id'], conditions: ['id="' + issueId + '"'] }, function(error, results) {
		if (callback instanceof Function) callback(error, results);
	}); 
}

/* getCommentAuthor
 * Gets the author of the comment 
 * 
 * @param commentId The id of the comment 
 * @param callback The callback (error, results)
 */ 
function getCommentAuthor(commentId, callback) { 
	dbAccess.find('comments', { properties:['user_id'], conditions: ['id="' + commentId + '"'] }, function(error, results) {
		if (callback instanceof Function) callback(error, results);
	});
}

/* updateOnCommentVote 
 * A helper function which update reputations for the issue author and voter when a comment is voted upon.
 *
 * @param commentId The id of the comment that was voted on
 * @param userId The id of the user who voted 
 * @param direction The vote direction (up or down) 
 * @param callback The callback (err) 
 */ 
function updateOnCommentVote(commentId, userId, direction, callback) {
	getCommentAuthor(commentId, function(error, results) { 
		if (error) { 
			if (callback instanceof Function) return callback(error); 
		}
		else if (results.length != 1) { 
			if (callback instanceof Function) return callback('Comment author not found'); 
		}
		else { 
			var points = (direction == Direction.Up) ? commentedOnPoints : -commentedOnPoints; 
			addToReputation(results[0].user_id, points, function(authErr, authScore) { 
				if (error) { 
					if (callback instanceof Function) callback(authErr);
				} 
				else { 
					addToReputation(userId, points, function(voterErr, voterScore) { 
						if (callback instanceof Function) callback(voterErr); 
					});
				}
			}); 
		}
	});
}

/* updateOnSignUp
 * Adjusts the reputation for a user when they sign-up 
 * 
 * @param name The name of the user
 * @param email The email of the user 
 * @param callback The callback (err) 
 */ 
exports.updateOnSignUp = function(name, email, callback) {
	dbAccess.find('users', { properties:['id'], conditions: ['name="' + name + '"', 'email="' + email + '"' ] }, 
		function(error, results) {
			if (error) { 
				if (callback instanceof Function) callback(error); 
			}
			else if (results.length != 1) { 
				if (callback instanceof Function) callback('User not found'); 
			}
			else { 
				addToReputation(results[0].id, signUpPoints, function(err, score) { 
					if (callback instanceof Function) callback(err); 
				});
			}
		}
	); 
}

/* updateOnAddIssue
 * Adjust the reputation for an issue author when a new issue is added 
 * 
 * @param issueId The id of the issue that was added 
 * @param userId The id of the user who added the issue 
 * @param callback The callback (err) 
 */ 
exports.updateOnAddIssue = function(issueId, userId, callback) { 
	dbAccess.find('issues', { properties:['user_id'], conditions: ['id="' + issueId + '"'] }, 
		function(error, results) {
			if (error) { 
				if (callback instanceof Function) callback(error); 
			}
			else if (results.length != 1) { 
				if (callback instanceof Function) callback('Issue not found');
			}
			else { 
				addToReputation(results[0].user_id, addIssuePoints, function(err, score) { 
					if (callback instanceof Function) callback(err); 
				}); 
			} 
		}
	);
}

/* updateOnAddComment
 * Adjusts the reputation for the issue author and commenter when a new comment is added 
 *
 * @param issueId The id of the issue that was commented on 
 * @param userId The id of the user who made the comment 
 * @param comment The comment that was added 
 * @param callback The callback (err) 
 */ 
exports.updateOnAddComment = function(issueId, userId, comment, callback) { 
	exports.getReputation(userId, function(error, score) {
		if (error) { 
			if (callback instanceof Function) return callback(error); 
		}
		
		var lengthDeduction = getCommentLengthDeduction(comment); 
		var offensiveWordingDeduction = getOffensiveMaterialDeduction(comment); 
		var points = addCommentPoints + lengthDeduction + offensiveWordingDeduction; 
		
		addToReputation(userId, points, function(err) { 
			if (err) { 
				if (callback instanceof Function) return callback(err); 
			}
			getIssueAuthor(issueId, function(issueErr, results) { 
				if (issueErr) { 
					if (callback instanceof Function) callback(issueErr); 
				}
				else if (results.length != 1) { 
					if (callback instanceof Function) callback('Issue author not found'); 
				}
				else { 
					addToReputation(results[0].user_id, commentedOnPoints, function(authErr) { 
						if (callback instanceof Function) callback(authErr); 
					});
				} 
			}); 
		}); 
	}); 
}

/* updateOnIssueUpVote 
 * Adjusts the reputation for the issue author and commenter when an issue is voted up 
 *
 * @param issueId The id of the issue that was commented on 
 * @param userId The id of the user who made the comment 
 * @param callback The callback (err) 
 */ 
exports.updateOnIssueUpVote = function(issueId, userId, callback) {
	updateOnIssueVote(issueId, userId, Direction.Up, function(err) {
		if (callback instanceof Function) callback(err); 
	}); 
}

/* updateOnIssueUpVote 
 * Adjusts the reputation for the issue author and commenter when an issue is voted down 
 *
 * @param issueId The id of the issue that was commented on 
 * @param userId The id of the user who made the comment 
 * @param callback The callback (err) 
 */ 
exports.updateOnIssueDownVote = function(issueId, userId, callback) {
	updateOnIssueVote(issueId, userId, Direction.Down, function(err) {
		if (callback instanceof Function) callback(err); 
	}); 
}

/* updateOnCommentUpVote 
 * Adjusts the reputation for the comment author and commenter when an comment is voted up
 *
 * @param commentId The id of the issue that was commented on 
 * @param userId The id of the user who made the comment 
 * @param callback The callback (err) 
 */ 
exports.updateOnCommentUpVote = function(commentId, userId, callback) {
	updateOnCommentVote(commentId, userId, Direction.Up, function(err) { 
		if (callback instanceof Function) callback(err); 
	});  
}

/* updateOnCommentDownVote 
 * Adjusts the reputation for the comment author and commenter when an comment is voted down
 *
 * @param commentId The id of the issue that was commented on 
 * @param userId The id of the user who made the comment 
 * @param callback The callback (err) 
 */ 
exports.updateOnCommentDownVote = function(commentId, userId, callback) {
	updateOnCommentVote(commentId, userId, Direction.Down, function(err) { 
		if (callback instanceof Function) callback(err); 
	}); 
}
