var Mustache = require('mustache'),
	fs = require('fs'), 
	fileUtil = require('fileUtil'), 
	Cache = require('cache').Cache,
	querystring = require('querystring');

var layoutsPath = 'views/layouts/';
var defaultLayoutPath = layoutsPath + 'defaultLayout.html';
var defaultPageTitle = 'CivicConnect';
var defaultQuickTaskButtons = 'views/layouts/partials/defaultQuickTaskButtons_partial.html';
var fileCache = new Cache();  

/*
 * This method is intended to be added to the http.Response object.  
 */
render = function(template, view, partials, send_fun){
	res = this;
	view = view || {}; //Removes the need to pass in the 'view' argument.
	
	// TODO: Is it OK to assume 'text/html' at this point?
	res.setHeader('Content-Type', 'text/html');
	
	quickTaskButtons_partial = view.quickTaskButtons_partial || defaultQuickTaskButtons;
	
	retrieveFiles(generateLayout); 
	
	function retrieveFiles(callback) { 
		var filesToImport = []; 
		if (!fileCache.contains(template)) { filesToImport.push(template); }
		if (!fileCache.contains(defaultLayoutPath)) { filesToImport.push(defaultLayoutPath); } 
		if (!fileCache.contains(quickTaskButtons_partial)) { filesToImport.push(quickTaskButtons_partial); } 
		
		if (filesToImport.length == 0) { callback(); }  
		fileUtil.readFiles(filesToImport, function(err, results) { 
			if (err) throw err; 
			for (var i = 0; i < filesToImport.length; i++) {
				var filename = filesToImport[i]; 
				fileCache.add(filename, results[filename]); 
			}
			callback(); 
		}); 
	}
	
	function generateLayout() { 
		var contentData = fileCache.get(template); 
		var layoutData = fileCache.get(defaultLayoutPath); 
		var partialData = fileCache.get(quickTaskButtons_partial); 
		
		contentHTML = Mustache.to_html(contentData.toString(), view, partials, send_fun);
		
		res.request.getUser(function(error, user) {
			if (error) throw error; 
					
			layoutPartials = {}
			layoutPartials.quickTaskButtons = partialData.toString();
			
			layoutContent = view.layoutContent || {};
			layoutContent.content = contentHTML.toString();
			layoutContent.user = user;
			layoutContent.user_name = (user) ? user.name: '';
			
			extractFlashFromCookie(res);
			if(!res.flash.isEmpty())
				layoutContent.flash = res.flash;
			
			layoutContent.pageTitle = layoutContent.pageTitle || view.pageTitle || defaultPageTitle;
			layoutContent.quickTaskButtons = view.quickTaskButtons;
			
			fullHTML = Mustache.to_html(layoutData.toString(), layoutContent, layoutPartials);
			
			res.write(fullHTML);
			res.end();
		});
	}
}

/*
 * This method is intended to be added to the http.Response object.  
 */
redirectTo = function(path){
	if(!this.flash.isEmpty()){
		addCookie(this, 'flash=' + JSON.stringify(this.flash))
	}
	this.statusCode = 302;
	this.setHeader('Location', path);
	console.log("Ending response"); 
	this.end();
}

function addCookie(res, cookie){
	//TODO: assumes there are 0 or 1 cookies already set. What if there are 2+?
	cookies = [];
	cookies.push(res.getHeader('Set-Cookie'));
	cookies.push(cookie);
	res.setHeader('Set-Cookie', cookies);
}

flash = function(){
	this.error = [];
	this.message = [];
	this.success = [];
	this.addError = function(error){
		this.error.push({error: error});
	}
	this.addMessage = function(message){
		this.message.push({message: message});
	}
	this.addSuccess = function(success){
		this.success.push({success: success});
	}
	this.isEmpty = function(){
		return (this.error.length + this.message.length + this.success.length) == 0;
	}
}

function extractFlashFromCookie(response){
	request = response.request;
	currentFlash = response.flash;
	if(request.headers.cookie){
		cookies = querystring.parse(request.headers.cookie, '; ');
		flashCookie = cookies.flash;
		if(flashCookie){
			newFlash = JSON.parse(flashCookie);
			for(message in newFlash){
				currentFlash[message] = currentFlash[message].concat(newFlash[message]);
			}
			addCookie(response, 'flash=0; Expires=Thu, 01-Jan-1970 00:00:01 GMT')
		}
	}
}

exports.setUpTemplating = function(request, response){
	response.flash = new flash();
	response.request = request;
	response.redirectTo = redirectTo;
	response.render = render;
}