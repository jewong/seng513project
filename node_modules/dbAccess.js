/* dbAccess.js
 *
 * Authors:
 * - Russ
 * - Dylan
 * - Andrew
 *
 * Desc:
 *	Abstract layer for masking database functions and methods.
 *
 * How to use:
 *	Require the .js file like any other module but with the following syntax:
 *		var dbAccess = require('dbAccess');
 *
 * IMPORTANT:
 *			when specifying parameters in values or conditions, use double quotation ".." on values
 *			Example:    .. values: 'name="Bob"' ...     
 */

var sqlite = require('sqlite'),
	//db = new sqlite.Database(),
	qs = require('querystring'),
	util = require('util'),
	DATABASE_NAME = 'db/CivicConnect.db';

/*
 * create - insert a new row into the database
 *		1. table 		   STRING 	MANDATORY					- table to select from
 *		2. params  		   OBJECT								- Object containing all the variables
 *			- values	   ARRAY	MANDATORY					- Array of data to be inserted.  Ex: "INSERT INTO table (a,b,c) VALUES ('x','y','z')" values is ['a="x"','b="y"','c="z"']
 *		3. call_back	   METHOD	OPTIONAL					- return function for errors, second parameter is the id of the row that was just inserted.
 *		
 *		Example: create('users', { values: ['name="John"', 'email="johndoe@gmail.com"', 'password="blah"', 'neighborhood="blah"', 'postal_code="blah"'] }, done);
 */
exports.create = function(table, params, call_back)
{
	var db = new sqlite.Database();
	// DEFAULT VALUES
	params.values = params.values || new Array();
	var columns = "(";
	var values = "(";
	var query = "INSERT INTO ";
	
	// 1. INSERT INTO WHERE
	query += table + " ";
	if (params.values.length>0) {
		// VALUES SPLIT
		for (var index in params.values) {
			var splitResults =  params.values[index].split("=");
			columns += splitResults[0];
			values += splitResults[1];
			
			if (index != params.values.length - 1) {
				columns += ",";
				values += ",";
			} 
			else {
				// Conclude the clause
				columns += ")";
				values += ")";
			}
		}
		
		// Finalizing the query
		query += columns + " VALUES " + values;
		// EXECUTE QUERY
		db.open(DATABASE_NAME, function(open_error) {
			// Can't open database - then return and call_back errors
			if (open_error != undefined)
				return call_back(open_error);
			db.execute(query, function (execute_error) {
				// Get the id of the row we just inserted
				db.execute("SELECT last_insert_rowid() \"id\";", function (execute_error, results) {
					if (execute_error) {
						util.log("Error in dbAccess.create(). Can't get id of row we just inserted.." + execute_error);
						// Close the db connection
						db.close(function (close_error) {
							if (close_error) {
								util.log("error closing db in dbAccess.create");
								util.log(close_error);
							}
							if (call_back instanceof Function) { call_back(execute_error, -1); }
						})
					}
					else {
						db.close(function (close_error) {
							if (call_back instanceof Function) { call_back(execute_error, results[0].id); } 
						})
					}
				});
			});
		});
	} 
	else { 
		call_back({ stack: '[db.create]', arguments: undefined, type: undefined, message:'no parameters given' });
	} 
}

/*
 * find - returns rows based on certain parameters.
 *		1. table 		   STRING 	MANDATORY					- table to select from
 *		2. params  		   OBJECT								- Object containing all the variables
 *			- properties   ARRAY 	OPTIONAL  [default: '*']	- columns to select. Ex: "SELECT id, date FROM table" properties is ['id', 'date']
 *		    - conditions   ARRAY	OPTIONAL  [default]			- column conditions. Ex: "SELECT id FROM table WHERE id=5" conditions is ['id=5']
 *		    - limit		   STRING	OPTIONAL  [default]			- limits the number of rows to passback. Ex: "SELECT * FROM table LIMIT 10" limit is '10'
 *			- orderby	   STRING	OPTIONAL  [default]			- orders the resulting rows by a column and DESC or ASC. Ex: "SELECT * FROM table
 *																	ORDERBY date DESC" orderby is 'date desc'
 *		3. call_back	   FUNCTON	MANDATORY					- returns the rows to the function to handle
 *
 *	 	Example: find('table_name', { properties:['id','date'], conditions:['id="4" OR id="5"','user_id="3"'], limit:5, orderby:'date asc' }, callback);
 *			-- where function callback(error, results) {..}
 *			-- var results will contain the result
 */
exports.find = function(table, params, call_back)
{
	var db = new sqlite.Database();
	// DEFAULT VALUES
	params.properties = params.properties || new Array();
	params.conditions = params.conditions || new Array();
	params.limit = params.limit || -1;
	params.orderby = params.orderby || '';
	// 1. SELECT WHAT
	var query = "SELECT ";
	// PROPERTIES
	if (params.properties.length == 0) { query +="*"; } 
	else {
		for(var index in params.properties) {
			query += params.properties[index];
			if (index != params.properties.length - 1)
				query += ",";
		}
	}
	// 2. FROM TABLE
	query += " FROM " + table;
	// 3. WHERE CONDITIONS
	if (params.conditions.length > 0) {
		query +=" WHERE ";
		for (var index in params.conditions) {
			query += params.conditions[index];
			if(index != params.conditions.length - 1)
				query += " AND ";
		}
	}
	// 4. ORDERBY
	if (params.orderby.length > 0)
		query += " ORDER BY " + params.orderby;
	// 5. LIMIT
	if (params.limit != -1)
		query += " LIMIT " + params.limit;
	// EXECUTE QUERY
	db.open(DATABASE_NAME, function(open_error) {
		// Cannot open database - then return and call_back errors
		if (open_error != undefined)
			return call_back(open_error);
		// Execute query
		db.execute(query, function (execute_error, rows) {
			db.close(function () {
				if (call_back instanceof Function) { call_back(execute_error, rows); } 
			});
		});
	});
}
/*
 * update - updates row information.
 *		1. table 		   STRING 	MANDATORY					- table to select from
 *		2. params  		   OBJECT								- Object containing all the variables
 *			- values  	   ARRAY 	OPTIONAL  [default: '*']	- Array of columns and new values. Ex: ['id=5', 'title='new']
 *		    - conditions   ARRAY	OPTIONAL  [default]			- Array of conditions of which rows to be updated. Ex: ['id=5', 'user_id=1']
 *		3. call_back	   FUNCTON	OPTIONAL					- return function
 *
 *	 	Example: update('table_name', { values:['column_1="value"','column_2="value"'], conditions:['condition_1="val1"', 'condition_2="val2" OR condition_3="val3"'] }, callback);
 */
exports.update = function(table, params, call_back)
{
	var db = new sqlite.Database();
	// DEFAULT VALUES
	params.values = params.values || new Array();
	params.conditions = params.conditions || new Array();

	// 1. UPDATE WHAT
	var query = "UPDATE ";
	// 2. FROM TABLE
	query += table;
	// 3. SET VALUES
	if (params.values.length > 0) {
		query +=" SET ";
		for (var index in params.values) {
			query += params.values[index];
			if(index != params.values.length - 1)
				query += ",";
		}
	}
	// 4. WHERE CONDITIONS
	if (params.conditions.length > 0) {
		query += " WHERE ";
		for(var index in params.conditions) {
			query += params.conditions[index];
			if(index != params.conditions.length-1)
				query += " AND ";
		}
	}
	// EXECUTE QUERY
	db.open(DATABASE_NAME, function(open_error) {
		// Cannot open database - then return and call_back errors
		if (open_error != undefined)
			return call_back(open_error);
		// Execute query
		db.execute(query, function (execute_error) {
			db.close(function () {
				if (call_back instanceof Function) { call_back(execute_error); } 
			});
		});
	});
}
/*
 * remove - updates row information.
 *		1. table 		   STRING 	MANDATORY					- table to select from
 *		2. params  		   OBJECT								- Object containing all the variables
 *		    - conditions   ARRAY	OPTIONAL  [default]			- Array of conditions of which rows to be updated. Ex: ['id=5', 'user_id=1']
 *		3. call_back	   FUNCTON	MANDATORY					- return function
 *
 *	 	Example: remove('table_name', { conditions:['condition_1', condition_2 OR condition_3'] }, callback);
 */
exports.remove = function(table, params, call_back)
{
	var db = new sqlite.Database();
	// DEFAULT VALUES
	params.conditions = params.conditions || new Array();
	// 1. DELETE WHAT
	var query = "DELETE";
	// 2. FROM TABLE
	query += " FROM " + table;
	// 3. WHERE CONDITIONS
	if (params.conditions.length > 0) {
		query += " WHERE ";
		for(var index in params.conditions) {
			query += params.conditions[index];
			if (index != params.conditions.length - 1)
				query += " AND ";
		}
		// EXECUTE QUERY
		db.open(DATABASE_NAME, function(open_error) {
			// Cannot open database - then return and call_back errors
			if (open_error != undefined)
				return call_back(open_error);
			// Execute query
			db.execute(query, function (execute_error) {
				db.close(function () {
					if (call_back instanceof Function) { call_back(execute_error); } 
				});
			});
		});
	}
}

/*
 * runQuery
 *		Generic query script execution
 *		usage:
 *			runQuery("select .. ... .... ", call_back);     where call_back(error, results) stores the results
 */
exports.runQuery = function(query, call_back)
{
	var db = new sqlite.Database();
	// EXECUTE QUERY
	db.open(DATABASE_NAME, function(open_error) {
		// Cannot open database - then return and call_back errors
		if (open_error != undefined)
			return call_back(open_error);
		// Execute query
		db.execute(query, function (execute_error, rows) {
			db.close(function () {
				if (call_back instanceof Function) { call_back(execute_error, rows); } 
			});
		});
	});
}
